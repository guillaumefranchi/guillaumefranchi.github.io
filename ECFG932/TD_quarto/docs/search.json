[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ECF932 : Techniques avancées en évaluation sensorielle",
    "section": "",
    "text": "Importation des données\nDans cette expérience, 103 consommateurs ont testé 8 jus d’orange, classés selon trois critères :\n\nMarque (Jafaden ou Tropicana)\nPulpe (Avec ou Sans)\nRéfrigéré (Oui ou Non).\n\nPour chaque test, les consommateurs ont donné une note :\n\nd’appréciation globale, sur une échelle de 1 à 9;\nd’appréciation sensorielle, sur une échelle de 1 à 5 pour 6 attributs :\n\nNuance de couleur\nIntensité de l’odeur\nGoût de sucre\nAcidité\nAmertume\nCaractère pulpeux.\n\n\n\nImporter le jeu de données orange.csv disponible sur connect. Effectuer un résumé rapide des données, et nettoyer le jeu de donneés si nécessaire (remplacement des valeurs manquantes, transformation des variables…)\n\n\n\nVoir la correction\nlibrary(tidyverse)\norange &lt;- read.csv(\"orange.csv\",sep=\";\")\nsummary(orange)\norange &lt;- orange %&gt;% mutate_at(c(1:2,4:9),.funs = as.factor)\nsum(is.na(orange)) # Aucune valeur manquante\n\n\n\n\nCartographie interne des préférences\nAvant d’effectuer une analyse JAR, le première chose à faire est de représenter la cartographie interne des préférences.\n\nCréer un jeu de données tel que chaque colonne représente les notes hédoniques (liking) données par chaque consommateur.\n\n\n\nVoir la correction\ncart_orange &lt;- orange %&gt;%\n  pivot_wider(id_cols = Juice,\n              names_from = Consumer,\n              values_from = Liking)\n\n\n\nA l’aide des packages FactoMineRet factoextra, effectuer une Analyse en Composantes Principales (ACP) de ce jeu de données, et faire la carte des préférences.\n\n\n\nVoir la correction\n# Pour que les noms s'affichent correctement sur le graphique\ncart_orange &lt;- as.data.frame(cart_orange)\nrownames(cart_orange) &lt;- cart_orange$Juice\ncart_orange &lt;- select(cart_orange,-Juice)\n\nlibrary(FactoMineR)\nlibrary(factoextra)\npca_cart &lt;- PCA(cart_orange,graph=FALSE)\nfviz_pca_biplot(pca_cart)\n\n\n\nCommenter ce graphique.\n\n\n\nReprésentations graphiques\n\nCréer une table répertoriant la note d’appréciation moyenne pour chaque jus d’orange. On pourra s’aider des fonctions group_by()et summarise().\n\n\n\nVoir la correction\nmean_liking &lt;- orange %&gt;%\n  group_by(Juice) %&gt;%\n  summarise(Mean=mean(Liking)) %&gt;%\n  ungroup()\n\n\n\nA l’aide de la fonction ggplot(), représenter ces notes moyennes par un diagramme en barres.\n\n\n\nVoir la correction\nggplot(mean_liking)+aes(x=Juice,y=Mean,fill=Mean)+\n  geom_bar(stat=\"identity\",width = 0.8,show.legend=FALSE)+\n  geom_text(aes(label=round(Mean,2)),position = position_stack(vjust = 0.9))+\n  theme_bw()+\n  labs(x=\"Jus d'orange\",y=\"Note moyenne\",title = \"Note d'appréciation moyenne des jus d'orange\")+\n  scale_fill_distiller(palette = \"RdYlBu\")\n\n\n\nReprésenter, pour chaque produit, un boxplot des notes d’appréciation globale données par les consommateurs.\n\n\n\nVoir la correction\nlibrary(RColorBrewer)\n\nggplot(orange)+aes(x=Juice,y=Liking,fill=Juice)+\n  geom_boxplot(show.legend = FALSE)+\n  scale_fill_brewer(palette = \"Set2\")+\n  theme_bw()+\n  labs(x=\"Jus d'orange\",y=\"Note hédonique\",title = \"Distribution des notes hédoniques des jus de fruit\")\n\n\n\nEffectuer un diagramme en barres donnant la répartition des notes JAR des différents attributs. On fera un graphique par produit.\n\nIndications :\n\nOn créera un tableau de données au format long avec la fonction pivot_longer(), où tous les attributs JAR seront mis dans la même colonne, en face desquels on donnera la note JAR donnée par les consommateurs.\nOn groupera ensuite les données par produit, attribut et note JAR, afin de compter le nombre de notes attribuées à chaque catégorie\nPour créer un graphique par produit, on peut utiliser la fonction facet_wrap().\n\n\n\nVoir la correction\ndf_graph_JAR_orange &lt;- orange  %&gt;%\n  pivot_longer(cols=4:9,names_to = \"Attribut\",\n               values_to = \"Note_JAR\") %&gt;% group_by(Juice,Attribut,Note_JAR) %&gt;%\n  summarise(Effectif = n())\nggplot(df_graph_JAR_orange)+aes(x=Attribut,\n                                y=Effectif,\n                                fill=Note_JAR)+\n  geom_bar(stat = \"identity\",color=\"grey20\")+\n  facet_wrap(~Juice,nrow=2)+\n  scale_fill_brewer(palette = \"RdYlBu\",direction = -1)+\n  theme_bw()+\n  labs(title=\"Répartition des notes JAR par produit\")+\n  theme(axis.text.x = element_text(angle=90))\n\n\n\nEffectuer une représentation semblable, mais en faisant un graphique par attribut.\n\n\n\nVoir la correction\nggplot(df_graph_JAR_orange)+aes(x=Juice,\n                                y=Effectif,\n                                fill=Note_JAR)+\n  geom_bar(stat = \"identity\",color=\"grey20\")+\n  facet_wrap(~Attribut,nrow=2)+\n  scale_fill_brewer(palette = \"RdYlBu\",direction = -1)+\n  theme_bw()+\n  labs(title = \"Répartition des notes JAR par attribut\",\n       x=\"Produit\")+\n  theme(axis.text.x = element_text(angle=90))\n\n\n\n\nAnalyse des pénalités (tous produits confondus)\n\nEcrire une fonction cat3() permettant de transformer un vecteur factoriel (comprenant des niveaux JAR de 1 à 5), en un nouveau vecteur factoriel codé comme suit :\n\n\nLa catégorie “Pas assez” est codée 1;\nLa catégorie “JAR” est codée 2;\nLa catégorie “Trop” est codée 3.\n\n\n\nVoir la correction\ncat3 &lt;- function(x){\n  y &lt;- as.numeric(x)\n  res &lt;- 1*(y&lt;3)+2*(y==3)+3*(y&gt;3)\n  return(as.factor(res))\n}\n\n\n\nAppliquer la fonction cat3() à tous les attributs JAR du jeu de données orange. On stockera le nouveau jeu de données dans un data-frame orange3cat.\n\n\n\nVoir la correction\norange3cat &lt;- orange %&gt;%\n  mutate_at(4:9,.funs = cat3)\n\n\n\nRecoder les niveaux des modalités JAR (ici 1,2, 3) avec le nom du descripteur sous la forme NomDescripteur_NoteJAR, par exemple Nc_2\n\n\n\nVoir la correction\nfor(i in 4:9){\n  levels(orange3cat[,i]) &lt;- paste(colnames(orange3cat)[i],1:3,sep=\"_\")\n}\n\n\n\nAvec la fonction JAR() du package SensoMineR, déterminer les pénalités des différentes catégories pour les attributs JAR.\n\n\n\nVoir la correction\nlibrary(SensoMineR)\n\njar_orange &lt;- JAR(orange3cat,col.p = 2,col.j = 1,col.pref = 3,jarlevel = 2)\n\n\n\nQuels sont les effets sur la note d’appréciation globale qui vous semblent pertinent de retenir ? Justifier.\nAvec le code suivant, représenter graphiquement les pénalités en fonction de la fréquence de l’attribut JAR considéré. Faire un graphique par produit.\n\n\n\nVoir la correction\npar(mfrow=c(2,4))\nfor (i in 1:nlevels(orange3cat$Juice)){\n  plot(jar_orange,name.prod=levels(orange3cat$Juice)[i],model=1, \n       ylab=\"mean drops (all products\")\n  points(jar_orange$Frequency[,i],jar_orange$penalty1[,1],\n         pch=19, col=rep(c(\"skyblue\",\"tomato\")))\n}\npar(mfrow=c(1,1))\n\n\nQuels semblent être les inconvénients de cette fonction ?\n\nOn se propose à présent d’effectuer “manuellement” cette analyse des pénalités. Cela aura l’inconvénient d’être un peu plus long, mais cela possède aussi différents avantages :\n\n\non explore plus en détails les données;\non peut faire des graphiques beaucoup plus soignés;\non pourra alors conduire nos analyses par produit.\n\nCréer tout d’abord, à partir du data-frame orange, un data-frame df_penalty, ou on retire les colonnes Juice et Consumer (elles ne présentent pas d’intérêt si on mène une analyse tous produits confondus).\nRecoder ensuite les attributs JAR avec la fonction cat3().\n\n\nVoir la correction\ndf_penalty &lt;- orange %&gt;% select(-Juice,-Consumer) %&gt;%\n  mutate_if(.predicate = is.factor,.funs = cat3)\n\n\n\nTransformer df_penaltyen format long, comme on avait pu le faire précédemment.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  pivot_longer(cols=2:7,names_to = \"Attribut\",values_to = \"Note_JAR\") %&gt;%\n  arrange(Attribut,Note_JAR)\n\n\n\nGrouper les lignes du data-frame par attribut et évaluation JAR, puis calculer la moyenne et l’écart-type des appréciations globales par groupe, ainsi que les effectifs de chaque groupe.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  group_by(Attribut,Note_JAR) %&gt;%\n  summarise(Mean_Liking = mean(Liking),\n         Sd_Liking = sd(Liking),\n         Nb_cat = n()) %&gt;%\n  ungroup()\n\n\n\n\n\n\n\n\n\n\n\nCalculer les pénalités pour chaque catégorie, ainsi que les degrés de liberté pour chaque catégorie dans le test de comparaison de moyennes de Student.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  group_by(Attribut) %&gt;%\n  mutate(Mean_Drop = Mean_Liking[2]-Mean_Liking,\n         DDL = Nb_cat+Nb_cat[2]-2) %&gt;%\n  ungroup()\n\n\n\nCréer une fonction T_calc() qui prendra comme paramètres :\n\n\nla pénalité de moyenne;\nles effectifs des catégories “JAR” et “Trop”/“Pas assez”“;\nles écart-types de ces catégories,\n\net qui calcule la statistique de test associé au test de Student.\n\n\nVoir la correction\nT_calc &lt;- function(mdrop,n1,n2,s1,s2){\n  sqrt(n1+n2-2)*mdrop/sqrt(((n1-1)*s1^2+(n2-1)*s2^2)*(1/n1+1/n2))\n}\n\n\n\nCréer également des fonctions borne_inf() et borne_sup() permettant de calculer les bornes d’un intervalle de confiance de la pénalité dans ce dernier cas.\n\n\n\nVoir la correction\nborne_inf &lt;- function(mdrop,n1,n2,s1,s2){\n  mdrop-qt(0.975,n1+n2-2)*sqrt(((n1-1)*s1^2+(n2-1)*s2^2)*(1/n1+1/n2))/sqrt(n1+n2-2)\n}\n\nborne_sup &lt;- function(mdrop,n1,n2,s1,s2){\n  mdrop+qt(0.975,n1+n2-2)*sqrt(((n1-1)*s1^2+(n2-1)*s2^2)*(1/n1+1/n2))/sqrt(n1+n2-2)\n}\n\n\n\nCalculer ensuite les statistiques de test pour chaque attribut, ainsi que les bornes des intervalles de confiance associés à chaque pénalité. Calculer également la fréquence (par attribut) associée à chaque catégorie\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  group_by(Attribut) %&gt;%\n  mutate(T_stat = T_calc(Mean_Drop,Nb_cat,Nb_cat[2],Sd_Liking,Sd_Liking[2]),\n         Borne_Inf=borne_inf(Mean_Drop,Nb_cat,Nb_cat[2],Sd_Liking,Sd_Liking[2]),\n         Borne_Sup=borne_sup(Mean_Drop,Nb_cat,Nb_cat[2],Sd_Liking,Sd_Liking[2]),\n         Freq = Nb_cat/sum(Nb_cat)) %&gt;%\n  ungroup()\n\n\n\nAjouter les p-values associées aux statistiques calculées.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  mutate(p_value = 1-pt(T_stat,DDL))\n\n\n\nEnfin, ajouter deux variables qualitatives précisant si :\n\n\nles pénalités doivent être prises en compte;\nles pénalités sont significatives.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  mutate(Comm = Freq &gt;=0.2 & Nb_cat &gt;=15,\n         Signif = p_value &lt;0.05) %&gt;%\n  mutate(Signif = factor(Signif,\n         levels=c(TRUE,FALSE),\n         labels=c(\"Oui\",\"Non\")))\n\n\n\nRetirer enfin les catégories “JAR”.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  filter(Note_JAR !=2)\n\n\n\nRéaliser le graphique croisé des pénalités et des fréquences des attributs. On ajoutera :\n\n\nUne ligne verticale à la fréquence 0.2;\nles intervalles de confiance;\nune couleur indiquant si la pénalité est significative.\n\n\n\nVoir la correction\nggplot(df_penalty)+aes(x=Freq,y=Mean_Drop,colour=Signif)+\n  geom_point()+\n  geom_errorbar(aes(ymin = Borne_Inf,ymax = Borne_Sup),width = 0.02)+\n  geom_vline(xintercept = 0.2,color=\"skyblue\",\n             linetype=\"dashed\",linewidth=1)+\n  geom_text(aes(label=paste(Attribut,Note_JAR,sep=\"_\")),show.legend = FALSE)+\n  theme_bw()+\n  labs(x=\"Fréquence\",y=\"Pénalité\",title = \"Graphique croisé des pénalités\")+\n  guides(colour=guide_legend(title = \"Significatif\"))\n\n\n\n\nPénalités pondérées\n\nAjouter une colonne Penalite_W au data-frame df_penalty, calculant les pénalités pondérées. On fixera à 0 l’ensemble des pénalités qui ne sont pas pertinentes.\n\n\n\nVoir la correction\ndf_penalty &lt;- df_penalty %&gt;%\n  mutate(Penalite_W = Freq*Mean_Drop*Comm) \n\n\n\nRéaliser alors un diagramme en barres des pénalités pondérées, et tracer un seuil déterminant si les défauts sont majeurs ou non.\n\n\n\nVoir la correction\ndf_penalty &lt;-df_penalty %&gt;%\n  mutate(Attribut=paste(Attribut,Note_JAR,sep=\"_\"))\n\nggplot(df_penalty)+aes(x=Attribut,y = Penalite_W)+\n  geom_bar(stat=\"identity\",color=\"grey20\",fill=\"tomato\")+\n  geom_hline(yintercept = 1,color=\"skyblue\",\n             linetype=\"dashed\",linewidth=1)+\n  theme_bw()+\n    labs(y=\"Pénalité pondérée\",title = \"Graphique des pénalités pondérées\")+\n  theme(axis.text.x = element_text(angle=90))\n\n\n\n\nAnalyse exploratoire\n\nAprès avoir créer un individu fictif idéal, réaliser une Analyse en Composantes Principales (ACP) des évaluations JAR du jeu de données. Interpréter.\n\n\n\nVoir la correction\ndf_orange_pca &lt;- orange %&gt;%\n  mutate_at(.vars = 4:9,.funs=as.numeric) %&gt;%\n  select(-Consumer) %&gt;%\n  mutate(Juice=as.character(Juice))\n\ndf_orange_pca[849,] &lt;-c(\"Ideal\",9,rep(3,6))\n\ndf_orange_pca &lt;- df_orange_pca %&gt;%\n  mutate(Juice=as.factor(Juice)) %&gt;%\n  mutate_at(2:8,.funs = as.numeric)\n\npca_orange &lt;- PCA(df_orange_pca,quali.sup = 1,quanti.sup = 2,\n                  graph = FALSE)\nplot.PCA(pca_orange,choix=\"var\")\nplot.PCA(pca_orange,choix=\"ind\",invisible = \"ind\",\n         col.quali = brewer.pal(9,\"Paired\"))\n\n\n\nRéaliser cette même ACP, mais cette fois avec les données agrégées.\n\n\n\nVoir la correction\ndf_orange_pca_agg &lt;- df_orange_pca %&gt;%\n  group_by(Juice) %&gt;%\n  mutate_at(2:8,.funs = mean) %&gt;%\n  ungroup()%&gt;%\n  unique()\n\npca_orange_agg &lt;- PCA(df_orange_pca_agg,quali.sup = 1,quanti.sup = 2,graph = FALSE)\n\nplot.PCA(pca_orange_agg,choix=\"var\")\nplot.PCA(pca_orange_agg,choix=\"ind\",invisible = \"ind\",\n         col.quali = brewer.pal(9,\"Paired\"))\n\n\n\nCréer un nouveau data-frame, ou le codage des attributs JAR est dédoublé :\n\n\nUne colonne “dummy” pour les attributs “Pas assez”.\nUne colonne “dummy” pour les attributs “Trop”.\n\nRéaliser ensuite l’ACP sur ce dernier jeu de données.\n\n\nVoir la correction\ndummy_codage &lt;- function(x){\n  y &lt;- as.numeric(x)\n  res &lt;- -2*(y==1) + (-1)*(y==2) + 0*(y==3) + 1*(y==4) + 2*(y==5)\n  return(res)\n}\n\norange_dummy &lt;- orange %&gt;%\n  mutate_at(.vars = 4:9,.funs = dummy_codage)\norange_dummy2 &lt;- matrix(rep(NA,nrow(orange)*(3+2*6)),nrow = nrow(orange)) %&gt;%\n  as.data.frame()\n\nfor(i in 0:5){\n  orange_dummy2[,4+2*i] &lt;- orange_dummy[4+i]*(orange_dummy[4+i]&lt;0)\n  orange_dummy2[,5+2*i] &lt;- orange_dummy[4+i]*(orange_dummy[4+i]&gt;0)\n  colnames(orange_dummy2)[4+2*i] &lt;- paste(colnames(orange_dummy)[4+i],\"-\",sep=\"\")\n  colnames(orange_dummy2)[5+2*i] &lt;- paste(colnames(orange_dummy)[4+i],\"+\",sep=\"\")\n}\n\norange_dummy2[,1:3] &lt;- orange_dummy[,1:3]\n\ncolnames(orange_dummy2)[1:3] &lt;- colnames(orange_dummy)[1:3]\n\norange_dummy2 &lt;- orange_dummy2 %&gt;% select(-Consumer)\n\npca_dummy &lt;- PCA(orange_dummy2,quali.sup = 1,quanti.sup = 2,\n                 graph = FALSE)\n\nplot.PCA(pca_dummy,choix=\"var\",\n         col.var = rep(brewer.pal(3,\"Set2\")[1:2],6))\nplot.PCA(pca_dummy,choix=\"ind\",invisible = \"ind\",\n         col.quali = brewer.pal(8,\"Set2\"))\n\n\n\nRéaliser l’anlyse des correspondances multiples du jeu de données.\n\n\n\nVoir la correction\ndf_orange_mca &lt;- orange %&gt;% select(-Consumer)\n\nmca_orange &lt;- MCA(X = df_orange_mca,quali.sup = 1,quanti.sup = 2,graph=FALSE)\n\nplot.MCA(mca_orange,invisible = \"ind\",\n         col.var = rep(brewer.pal(5,\"Set2\"),6),\n         col.quali.sup = \"black\")\n\n\n\nAprès avoir agréger les données, ré-effectuer enfin une analyse des correspondances.\n\n\n\nVoir la correction\norange_long &lt;- orange %&gt;%\n  select(-Liking,-Consumer) %&gt;%\n  pivot_longer(cols=2:7,names_to = \"Attribut\",values_to = \"Note_JAR\") %&gt;%\n  mutate(Attribut = paste(Attribut,Note_JAR,sep=\"_\"),.keep = \"unused\")%&gt;%\n  mutate(Attribut=as.factor(Attribut)) %&gt;%\n  #complete(Juice,Attribut) %&gt;%\n  arrange(Juice,Attribut)\n\ndf_orange_mca_agg &lt;- orange_long %&gt;%\n  group_by(Juice,Attribut) %&gt;%\n  summarise(Counts = n()) %&gt;%\n  ungroup() %&gt;%\n  complete(Juice,Attribut) %&gt;%\n  mutate_all(.funs = replace_na,replace=0) %&gt;%\n  pivot_wider(names_from = Attribut,values_from = Counts)\n\nca_orange &lt;- CA(df_orange_mca_agg,quali.sup = 1,graph=FALSE)\nwindows(width=1200,height=600)\nplot.CA(ca_orange,col.quali.sup = \"black\",\n        col.col = rep(brewer.pal(5,\"Set2\"),6),\n        ggoptions = list(size=2.5),label = \"col\")",
    "crumbs": [
      "Exercice 1 : Jus de fruits"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1"
  },
  {
    "objectID": "exo2.html",
    "href": "exo2.html",
    "title": "ECF932 : Techniques avancées en évaluation sensorielle",
    "section": "",
    "text": "Parfums\nOn considère cette fois-ci le jeu de données parfums.csv, disponible sur connect.\nDans cette expérience, on a demandé à 103 consommateurs leur avis sur 12 parfums :\n\nen leur faisant évaluer 21 critères sur une échelle JAR allant de 1 à 5 (codée de -2 à 2);\nen leur demandant une note d’appréciation globale de 1 à 9.\n\n\n\nReprésentations graphiques\n\nA la manière de l’Exercice 1, dresser la cartographie interne des préférences. Interpréter.\nRéaliser ensuite les autres graphiques permettant de résumer le jeu de données.\n\n\n\nAnalyse des pénalités\n\nEffectuer l’analyse des pénalités, tous produits confondus, et tester leur significativité statistique.\nChoisir ensuite un parfum en particulier, et effectuer l’analyse des pénalités pondérées sur ce dernier.\n\nCe produit posède-t-il des défauts majeurs à corriger ?\n\n\nAnalyse factorielle\n\nRéaliser une analyse factorielle complète du jeu de données, et interpréter.",
    "crumbs": [
      "Exercice 2 : Parfums"
    ]
  }
]