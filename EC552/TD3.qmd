---
title: "TD3 : Les data-frames"
number-sections: true
number-depth: 2
number-offset: 0
---

C'est peut-être l'objet le plus important et le plus utilisé dans R. Il s'agit d'un tableau de données, mais contrairement aux matrices, on peut avoir différents types de données dans un même data-frame.

# Création d'un data frame

- On crée deux variables *x* et *y* contenant $n=100$ nombres distribués selon une loi uniforme continue sur \[0,20\] (fonction `runif()`) et une variable *gr*.

***Expliquer le résultat du code correspondant*** *(la fonction `round()` permet d'arrondir)*.

```{r eval=TRUE}
x <- round(runif(100,0,20),1)
y <- round(runif(100,0,20),1)
gr <- sample(c("ING1","ING2"),size=100,replace=T,prob=c(0.6,0.4))
df<-data.frame(NoteF=x,NoteM=y,gr=gr)
```

- L'indexation des éléments dans un data-frame est la même que dans une matrice :

```{r eval=TRUE}
df[1,1]
```

- On peut également sélectionner une colonne du data-frame via \$

```{r eval=TRUE}
df$NoteF
```
# Importation d'un data frame inclus dans un package

- Pour accéder aux data-frames de R :

```{r}
data()
```

- Grâce à la fonction `help()`, on peut obtenir de l'aide sur l'un des data-frames :

```{r}
help("mtcars")
```

- On charge ensuite le jeu de données :

```{r eval=TRUE}
data("mtcars")
```

- Une fois le data frame importé on constate qu'il est présent dans la fenêtre *environnement*.

![Fenêtre environnement](Images/fig2.png)

# Importation d'une base de données externe

On peut utiliser une interface graphique pour ouvrir les fichiers contenant un data-frame. Les plus courants sont :

-   \*.csv *(Comma Separed Values)* : ce sont des fichiers de type tableaux sans mise en forme;
-   \*.xlsx : fichiers produits à partir du logiciel excel;
-   \*.ods : fichiers produits à partir du logiciel Calc de LibreOffice.

Ces fichiers peuvent s'importer dans l'environnement de travail avec les fonctions `read.csv()`, `read.table()`, ou `read.xlsx()` du package `readxl`.

***Exercice***

1. Importer le data-frame contenu dans le fichier **bordeaux.csv** disponible sur Connect *(à télécharger, et à placer dans le bon répertoire)*. Il s'agit des données de vin de Bordeaux issues de *Méthodes statistiques en gestion* de M. Tenenhaus, Dunod, 1994.

```{r}
#| code-fold: true
#| code-summary: "Voir la correction"
bordeaux <- read.csv("bordeaux.csv",
                     header = TRUE,row.names = 1)
```

2. A quoi correspondent les paramètres `header`et `row.names` ?

# Quelques fonctions utiles pour les data-frames

## La fonction `summary()`

Cette fonction permet de résumer l'ensemble des variables du data-frame.

```{r eval=TRUE}
summary(df)
```

## La fonction `apply()`

La fonction `apply()` permet d'appliquer une fonction sur les lignes (`MARGIN=1`) ou les colonnes (`MARGIN=2`) d'un data-frame.
Par exemple si on souhaite appliquer la fonction moyenne (`mean()`) sur les colonnes du data frame *df*, on utilise :

```{r eval=TRUE}
apply(df[,1:2],MARGIN=2,mean)
```

***Remarque :*** on n'a utilisé que les deux premières colonnes du data-frame car la troisième n'est pas numérique (donc on ne peut pas calculer sa moyenne).

## La fonction `factor()`

Cette fonction va être très importante pour la suite, et en particulier lorsque l'on va manipuler des jeux de donnnées en statistique.

- Un ***facteur*** est une variable qualitative (i.e. non numérique). Les valeurs prises par cette variable sont appelées ***modalités***.

***Exemples :***

  - Une variable qualitative peut décrire, pour un aliment, le type de nourriture *(modalités : Confiserie, Viande, Fruit, Légume,...)*.
  - Dans un sondage, une variable qualitative peut décrire le sexe de l'individu *(modalités : Homme, Femme, Non binaire)*.

- Il peut arriver que ces modalités soient codées. Par exemple dans certains jeux de données, on connaîtra le statut professionnel des participants *(modalités : en activité, en recherche d'emploi, étudiant, à la retraite)* mais on peut avoir choisi de coder les modalités par des nombres *(ici de 1 à 4)* mais cette variable demeure un facteur.


```{r eval=TRUE}
statut_pro<-sample(1:4,100,replace=TRUE)
## R ne voit pas qu'il s'agit d'un facteur car les modalités sont numériques
class(statut_pro)
table(statut_pro)
```

- On utilise la fonction `factor()` pour spécifier à R qu'il s'agit d'une variable qualitative. On voit le changement à travers `class()` ou `levels()` :

```{r eval=TRUE}
statut_pro<-factor(statut_pro)
class(statut_pro)
levels(statut_pro)
levels(statut_pro)<-c("en activité", "en recherche d'emploi",
                      "étudiant", "à la retraite")
table(statut_pro)
```

***Remarque :*** Les variables binaires (facteurs à deux modalités) sont souvent codées 0/1.

- On peut être amené à vouloir avoir les modalités d'un facteur classées dans un certain ordre. Pour ce faire, on va utiliser la fonction `labels()` avec l'ordre choisi :

```{r eval=TRUE}
statut_pro<-factor(statut_pro,labels=c("étudiants","en activité",
                                       "en recherche d'emploi","à la retraite"))
table(statut_pro)
```

***Attention*** les labels doivent être exactement écrits de la même façon que les levels si les modalités sont déjà écrites et sinon on peut directement agir sur les modalités via labels :

```{r}
data("mtcars")
help("mtcars")
mtcars$vs<-factor(mtcars$vs,levels=0:1,labels=c("V-shaped","straight"))
mtcars$am<-factor(mtcars$am,levels=0:1,labels=c("automatic","manual"))
```

# Exercices

## Exercice 1

1.  Charger le fichier de données `iris`. Lire l'aide de iris pour comprendre le jeu de données.

2.  Quel est le type de iris ? Quelles sont les dimensions de iris ?

3.  Appliquer la fonction `str()` à iris. A quoi correspondent les informations renvoyées ?

4.  Appliquer la fonction `summary()` à iris. A quoi correspondent les informations renvoyées ?

5.  Utiliser les fonctions `colnames()` et `rownames()`. Quelles sont les informations renvoyées ?

6.  A l'aide la fonction de texte `paste()` remplacer le nom des lignes par fleur_1, ..., fleur_150.

7.  Pour un data-frame on peut appeler une colonne par son nom en utilisant \$ : `iris$Sepal.Length`. En utilisant cette information donner la classe de la colonne *Species*.

8.  Quels sont les niveaux du facteur *Species* (fonction `levels()`) ?

9.  Créer une nouvelle colonne nommée *groupe* (on pensera à \$) dans le data frame iris identique à la colonne *Species*. Quelle est la classe de cette nouvelle colonne ?

10. Renommer les niveaux de la colonne *groupe* en *A*, *B*, *C* (*A* pour *setosa*, *B* pour *versicolor*, *C* pour *virginica*). Afficher les indices des lignes de `iris` correspondant au groupe *B*.

11. Créer l'ensemble des numéros de lignes correspondant aux fleurs du groupe *A*. Afficher les lignes de `iris` correspondant au groupe *A*.

12. En adoptant la même logique que la question précédente, afficher uniquement les lignes de `iris` où *Sepal.Length* est inférieur à 5.

13. Combien y a-t-il d'individus ayant la longueur des sépales inférieure à 5 ?

## Exercice 2

1.  Charger le data-frame `mtcars`. Combien de véhicules et de caractéristiques sur les véhicules sont contenus dans le data frame ?

2.  Deux caractéristiques sont mal identifiées dans le data-frame car ce sont des variables qualitatives *(facteurs)*. Rectifier en utilisant la fonction `as.factor()`.

3.  En utilisant l'aide du data-frame `mtcars` renommer les niveaux des deux facteurs précédents.

4.  Etablir la table de contingence de ces deux facteurs *(fonction `table()`)*

5.  Calculer la moyenne des 7 premières variables *(on utilisera les fonctions `mean()` et `apply()`)*.

6.  Reprendre la question précédente pour les voitures avec un moteur à plat. De même pour les voitures ayant un moteur en V et qui sont automatiques.

7.  Calculer le nombre de voitures ayant un moteur en V qui ont au moins 3 carburateurs.
