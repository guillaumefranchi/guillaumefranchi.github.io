---
title: "TD1 : Premiers pas dans R"
number-sections: true
number-depth: 2
number-offset: 0
---

# Premières commandes

Dans la console exécuter les lignes suivantes :

```{r echo=TRUE, eval=TRUE}
1 + 1
```

```{r echo=TRUE, eval=TRUE}
pi
```

```{r echo=TRUE, eval=TRUE}
sin(3*pi/2)
```

A partir de maintenant toutes les commandes seront enregistrées dans un fichier script nommé TD1.R.

Pour ce faire : **File -\> New File -\> R Script**

La plupart des fonctions mathématiques sont définies dans R (librairie `base`, chargée automatiquement).

# Les variables

Une variable est un objet référencé dans le programme qui associe un identificateur à une valeur d'un certain type.

-   ***L'identificateur*** est le nom de la variable utilisé pour l'appeler,
-   ***La valeur*** est ce que contient la variable,
-   ***Le type*** est l'ensemble dans lequel la variable prend sa valeur.

## Variables de type numérique

```{r echo=TRUE, eval=TRUE}
x=2
```

```{r echo=TRUE, eval=TRUE}
class(x)
```

```{r echo=TRUE, eval=TRUE}
## Supprimer x
rm(x)
```

## Variables contenant des caractères (on utilise `""`)

```{r echo=TRUE, eval=TRUE}
x <- "bonjour"
print(x)
```

***Remarque :*** On peut affecter une valeur à une variable avec le signe `=`, ou bien avec `<-`.

```{r echo=TRUE, eval=TRUE}
class(x)
```

## Variables contenant des booléens (Vrai ou Faux)

```{r echo=TRUE,eval =TRUE}
x <- TRUE
print(x)
```

```{r echo=TRUE,eval =TRUE}
class(x)
```

# Les vecteurs

Il s'agit d'un des objets de base de R, contenant plusieurs valeurs d'un même type (numérique, chaîne de caractères, booléen).

## Création d'un vecteur

-   Via la fonction `c()` (*pour combine*).

```{r echo=TRUE,eval=TRUE}
a1 <- c(1.5,2,3.2,-1.5,0,-1)
a2 <- c("fille","garçon","fille","fille","fille","fille")
a3 <- c(TRUE,FALSE,TRUE,TRUE)
```

```{r echo=TRUE,eval=TRUE}
class(a1)
class(a2)
class(a3)
```

***Exercice***

1)  Combiner les vecteurs a1 et a2 dans un nouveau vecteur a.

2)  Quelle est la classe du résultat ?

```{r}
#| code-fold: true
#| code-summary: "Voir la correction"
a<-c(a1,a2)
class(a)
```

-   Via la fonction `rep()`, qui permet d'écrire *n* fois la valeur *a* : `rep(a,n)`

```{r echo=TRUE,eval=TRUE}
rep(5,10)
```

***Exercice***

Créer un vecteur avec 5 fois "fille" et 10 fois "garçon".

```{r}
#| code-fold: true
#| code-summary: "Voir la correction"
a <- c(rep("fille",5),rep("garçon",10))
print(a)
```

-   Via la fonction `seq()`, qui définit une séquence de nombre entre *MIN* et *MAX* avec un pas de *L* : `seq(MIN,MAX,by=L)`

```{r eval=TRUE}
seq(0,1,by=0.1)
seq(10,20,by=5)
```

-   On peut aussi créer des vecteurs d'entiers successifs avec `:`

```{r eval=TRUE}
1:10
2:7
```

## Indexation et longueur d'un vecteur

-   La fonction `length()` permet de calculer le nombre de valeurs d'un vecteur (quelle que soit la nature du vecteur considéré).

```{r eval=TRUE}
length(a1)
length(a2)
```

-   Chaque élément d'un vecteur est repéré par un indice entre \[\].

```{r eval=TRUE}
a1[1]
a1[3]
```

-   Opérations sur les éléments d'un vecteur :

```{r eval=TRUE}
a1[1]+a1[3]
a1[1]/a1[3]
```

-   On peut changer la valeur de `a1[3]` en lui affectant une nouvelle valeur :

```{r eval=TRUE}
a1[3] <- -3
a1
```

-   On peut aussi ajouter de nouvelles valeurs au vecteur.

```{r eval=TRUE}
a1[12]<-10
a1[13]<-11
a1
```

-   On peut effectuer les opérations précédentes sur plusieurs valeurs du vecteur.

```{r eval=TRUE}
a1[c(12,13)] <- c(99,100)
a1
a1[7:11] <- 94:98
a1
```

## Les calculs de base avec un vecteur

-   On peut ajouter, soustraire, multiplier des vecteurs entre eux à condition qu'ils soient de même longeur et qu'ils soient numériques.

Les opérations sont alors effectuées terme à terme.

```{r eval=TRUE}
a1 <- seq(10,20,by=1)
a2 <- seq(20,30,by=1)
a1+a2
a2-a1
a1*a2
a2/a1
a1^2*log(a2)
```

-   ***Attention :*** si les vecteurs ne sont pas de la même longueur, les éléments du vecteur le plus court sont recyclés.

```{r eval=TRUE}
a1 <- c(1,2,3)
a2 <- 1:10
a1+a2
```

- On peut calculer la somme ou la moyenne des éléments d'un vecteur.

```{r eval =TRUE}
sum(a1)
mean(a1)
```

# Ouvrir l'aide

-   Toutes les fonctions prédéfinies dans R possèdent une vignette (description des arguments de la fonction, des sorties et un exemple utilisant la fonction). Pour accéder à cette aide on met un point d'interrogation devant le nom de la fonction.

***Exemple : Décrire la fonction sample***

```{r}
?sample
```

-   Une fonction comporte plusieurs arguments. Par exemple `sample(x, size, replace = FALSE, prob = NULL)`

-   Parmi les arguments, certains sont obligatoires :

    -   *x* est un vecteur dans lequel on va choisir des valeurs au hasard;
    -   *size* est la taille du résultat.

-   D'autres sont facultatifs (ils ont des valeurs par défaut), ici *replace* et *prob*.

```{r eval=TRUE}
sample(-10:10,1)
sample(-10:10,3)
```

# Un peu de logique

-   L'opérateur \| correspond à ***OU*** : A \| B est faux lorsque les deux événements A et B sont faux simultanément et est vrai dans tous les autres cas.

-   l'opérateur & correspond à ***ET*** : A & B est vrai uniquement lorsque les deux événements A et B sont vrais et est faux dans tous les autres cas.

***Exemple***

-   On définit un vecteur *x*:

```{r eval=TRUE}
set.seed("44")
# Permet de fixer la "graine", qui génère les nombres pseudo-aléatoires.
x=sample(-20:20,40,replace=TRUE)
x
```

-   On veut savoir quelles valeurs de *x* sont positives :

```{r eval=TRUE}
x>0
```

-   On veut savoir combien de valeurs de *x* sont postives:

```{r eval=TRUE}
sum(x>0)
```

-   Quelles sont les positions de ces valeurs ?

```{r eval=TRUE}
which(x>0)
```

-   Quels sont les indices des valeurs supérieure à 5 ou inférieure à 0 ?

```{r eval=TRUE}
which(x>5 | x<0)
```

-   Quels sont les indices des valeurs dans \[5,10\] ?

```{r eval=TRUE}
which(x>=5 & x<=10)
```

# Exercices

## Exercice 1

1.  Créer le vecteur *x* contenant le nom des villes suivantes Nantes, Brest, Rennes, Angers, Le Mans.

2.  Afficher le premier élément de *x*.

3.  Afficher tous les éléments de *x* sauf le premier.

4.  Afficher les trois premiers éléments de *x*.

5.  Afficher le deuxième et le quatrième élément de *x*.

6.  Classer les éléments de *x* dans l'ordre alphabétique puis anti-alphabétique grâce aux fonctions `sort()` et `rev()`.

## Exercice 2

1.  Créer un vecteur *y* contenant les entiers pairs inférieurs à 100 grâce à la fonction `seq()`.

2.  Ajouter à *y* les entiers impairs inférieurs à 100. On stockera la valeur obtenue dans une variable *S*.

3.  Déterminer la taille du vecteur *S* final.

4.  A l'aide de la fonction `rep()` créer un vecteur *sonnette* contenant 4 fois « ding » puis 4 fois « dong ».

5.  A l'aide de la fonction `sample()` créer un vecteur *melodie* contenant une succession aléatoire de « ding » et de « dong » de taille 100.

6.  Grâce à la fonction `table()`, déterminer combien il y a de « ding » et combien il y a de « dong » dans *melodie*.

## Exercice 3

1.  Générer un vecteur *x* de taille 100 de valeurs tirées selon une loi normale centrée réduite (i.e. de paramètres 0 et 1) grâce à la fonction `rnorm()`.

2.  Calculer la somme et la moyenne de *x* à l'aide des fonctions dédiées.

3.  Calculer le minimum, le premier quartile, la médiane, le troisième quartile et le maximum de x. La fonction `quantile()` bien utilisée vous donnera toutes ces informations directement...

4.  Générer le vecteur booléen indiquant si les nombres contenus dans x sont positifs (`TRUE`) ou non (`FALSE`). Combien de ces nombres sont-ils positifs ?

5.  Même question pour indiquer si les nombres sont compris entre -1 et 1.

6.  Afficher les indices des valeurs négatives de *x*.

7.  Afficher la valeur absolue des valeurs de *x* avec la fonction.

8.  Afficher la partie entière des valeurs de *x* .

9.  Afficher uniquement les valeurs positives de *x*.

10. Remplacer les valeurs négatives de *x* par 0. Vérifier le remplacement.
